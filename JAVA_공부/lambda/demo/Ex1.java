package me.blacksheepbell.demo;

public class Ex1 {
	
	public static void main(String[] args) {
	
		// NoLambda
		new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("NoLambda");
			}
		}).start();

		/*
		 * @ 람다 : 메소드의 행동에만 집중한다.
		 * 왜? 불필요한 명명 생략, 초간단, 의도명확, 병렬처리(MultiCore)에 유용
		 * 메소드의 이름(run),
		 * 메소드가 담겨 있는 클래스(Runnable)관심없어 생략할꺼야
		 * 행동에 필요한 [매개변수] 그리고 [행동]만 쓴다
		 */
		
		/*	## 람다가 병렬처리에 유용한 이유
		  	1. 함수형 프로그래밍의 가장 큰 특징은 객체의 상태가 불변한다는 점입니다. 
		 	계산과정에서 변수들이 초기값을 그대로 갖는 final 속성을 가지기 때문에 구조적으로 
		 	멀티스레드 환경에서 변수값을 서로 바꾸기 위한 동시성 관리가 없어집니다. 
		 	동시성 관리는 구현하는 것 자체가 매우 어려운데 변수상태가 불변한다면 동시성 관리가 필요없어지므로, 
		 	멀티스레드 개발이 보다 쉬워지게 되고, 동시성에 대한 사이드 이펙트를 고려하지 않아도 됩니다.

			2. 참조 투명성이란 함수를 호출하는 부분을 그 함수가 반환하는 결과를 대체했을때, 사이드 이펙트가 없는 것을 의미합니다. 
			이는 항상 같은 입력값에 항상 같은 결과가 도출됨을 의미합니다. 참조투명성은 함수형프로그래밍의 아주 중요한 특성입니다. 
			이는 멀티코어 환경에서 어떤한 스레드가 동시에 함수를 처리한다고 해도 사이드이펙트 없이 모두 동일한 값을 출력시킬 수 있습니다.
		 */
		new Thread(() -> 
			System.out.println("YesLambda")
		).start();
	}
	
	
}
